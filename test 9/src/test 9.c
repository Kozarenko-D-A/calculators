
#include<stdio.h>
#include<stdlib.h>
int main(int argc, char *argv[])
{


		FILE * in = fopen("input04.txt", "r");   // файл из которого берутся данные
	FILE * out = fopen("output.txt", "w");// файл в который записываются данные
	float * aV, *bV, *cV;  // Векторы для обработки и вектор результата
	float a1, b1, c1 = 0.0; // Скаляры для обработки и результат
	char c; // Тип операции '+', '-' или '*'
	char t; // Тип аргументов 'v' или 's'
	int size;// Число аргументов
	char h; //пробел
	fscanf(in, "%c", &c);  // fscanf считывает из файла *in символ которым является  операция
	if ((c != '+') && (c != '-') && (c != '*')) // оператор && с помощью которого выбирается нужная нам операция за счет сравнивания операндов слева на право. Если значения первого операнда достаточно, чтобы определить результат операции, второй операнд не вычисляется
	{
		printf("неизвестная операция: '%c'\n", c);
		exit(1); // завершение с кодом ошибки 1
	}
	fscanf(in, "%c", &h); // пробел
	fscanf(in, "%c", &t);  // считывает из файла *in символ которым является jбозначение использования отдельных чисел (s) или векторов (v)
	if ((t != 'v') && (t != 's')) {
		printf("Неизвестный тип аргументов: '%c'\n", t);
		exit(1);
	}
	if (t == 'v') { // если находит v , то дальше будут считатьсяч вектор
		fscanf(in, "%d", &size);  // считывает из файла *in число аргументов
		aV = (float *)malloc(size * sizeof(float));  // Функция size выделяет память под аргументы и результат
		bV = (float *)malloc(size * sizeof(float));
		cV = (float *)malloc(size * sizeof(float));

		for (int i = 0; i < size; i++)
			fscanf(in, "%f", &aV[i]);   	// Ввод обоих векторов
		for (int i = 0; i < size; i++)
			fscanf(in, "%f", &bV[i]);

		switch (c) {    // Переключение в зависимости от выбранной операции
		case '+':
			for (int i = 0; i < size; i++)
				cV[i] = aV[i] + bV[i];
			break;
		case '-':
			for (int i = 0; i < size; i++)
				cV[i] = aV[i] - bV[i];  // операции с векторами
			break;
		case '*':
			c1 = 0.0;   // Вычисляем скаляр, равный сумме покомпонентных произведений
			for (int i = 0; i < size; i++)
				c1 += aV[i] * bV[i];
			break;
		}
		fprintf(out, "(");  // выводит в  * out скобку открывания
		int first = 1;  // Является ли аргумент первым
		for (int i = 0; i < size; i++) {  // Вывод первого векторного аргумента
			if (first == 0)  // Перед всеми аргументами кроме первого нужен пробел
				fprintf(out, " ");    // выводит в * out пробел между векторами ,если размер вектора больше 1
			fprintf(out, "%f", aV[i]); // выводит в * out 1 вектор
			first = 0;  // Следующий аргумент не первый
		}
		fprintf(out, ") %c (", c); // выводит в  * out Скобку первого аргумента
		first = 1;  // Является ли аргумент первым
		for (int i = 0; i < size; i++) {  // Вывод первого векторного аргумента
			if (first  == 0)   // Перед всеми аргументами кроме первого нужен пробел
				fprintf(out, " ");   // выводит в * out пробел между векторами ,если размер вектора больше 1
			fprintf(out, "%f", bV[i]);  // выводит в * out 2 вектор
			first = 0;  // Следующий аргумент не первый
		}
		fprintf(out, ") = ");// выводит в * out скобку закрытия и знак ровно
		fprintf(out, "(");
		if (c == '*') {
			fprintf(out, "%f", c1);  // Результат - скаляр
			fprintf(out, ")");
		}
		else {
			first = 1;
			for (int i = 0; i < size; i++) {
				if (first == 0)
					fprintf(out, " ");
				fprintf(out, "%f", cV[i]);
				first = 0;

			}

			fprintf(out, ")\n");
		}

		free(aV);   //Функция free освобождает место в памяти , ранее выделенной с помощью malloc
		free(bV);
		free(cV);

	}
	else if (t == 's') {   // если находит s , то дальше будут считаться обычный калькуляторр, а не векторный

		fscanf(in, "%f", &a1);
		fscanf(in, "%f", &b1);
		switch (c) {
		case '+':
			c1 = a1 + b1;
			break;
		case '-':
			c1 = a1 - b1;
			break;
		case '*':
			c1 = a1 * b1;
			break;
		}
		fprintf(out, "%f %c %f = %f\n", a1, c, b1, c1);
	}

	fclose(in); // Fclose закрывает файл
	fclose(out);

	return 0;
}


// Козаренко Д.А. ИВТ 4 группа

